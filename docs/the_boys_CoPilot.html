<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Boys Shows</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Base */
    :root{
      --bg:#111; --fg:#eee; --accent:#f0c000;
      --block-show:#333; --block-season:#444; --block-item:#555;
      --blue:#4ea3ff; --green:#35c46d; --white:#fff; --red:#ff5c5c; --cyan:#4dd; --yellow:#fc3;
    }
    *{box-sizing:border-box}
    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg);
      color: var(--fg);
      padding: 16px;
      line-height: 1.35;
    }
    h1 {
      text-align: center;
      color: var(--accent);
      margin: 8px 0 16px;
    }

    /* Controls bar */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      align-items: center;
      justify-content: center;
      background: #1a1a1a;
      border: 1px solid #444;
      padding: 10px;
      margin-bottom: 14px;
    }
    .controls label{display:flex;align-items:center;gap:6px;cursor:pointer}
    .btn {
      padding: 6px 10px;
      border: 1px solid #555;
      background: #222;
      color: var(--fg);
      border-radius: 4px;
      cursor: pointer;
    }
    .btn:hover { background:#2a2a2a }

    /* Section blocks: collapsed by default */
    details {
      margin-bottom: 12px;
      border: 1px solid #444;
      background-color: #222;
    }
    summary {
      cursor: pointer;
      font-weight: bold;
      color: var(--accent);
      padding: 10px 12px;
      user-select:none;
    }
    /* Visual hierarchy titles */
    .title-show { color: var(--blue); }
    .title-season { color: var(--green); }
    .title-item { color: var(--white); }

    /* Level shading per container */
    .block-show { background: var(--block-show); }
    .block-season { background: var(--block-season); }
    .block-item { background: var(--block-item); }

    /* Flex rows for better TV readability (no horizontal scroll) */
    .flex-table {
      display: grid;
      grid-template-columns: 60px 160px 1fr 120px 160px; /* default layout for episodes/movies */
      gap: 6px;
      padding: 8px 12px;
      align-items: start;
    }
    .flex-row { display: contents; }
    .cell { padding: 6px 8px; border: 1px solid #555; background:#1a1a1a; }
    .cell.desc { grid-column: 3; } /* wider description */
    .flex-header .cell { background:#222; color: var(--accent); font-weight:bold; }
    .flex-table .cell:hover { background:#333; }

    /* Show header table */
    .flex-table.show {
      grid-template-columns: 120px 1fr 180px 140px 120px 1fr;
    }
    /* Season header table */
    .flex-table.season {
      grid-template-columns: 100px 120px 1fr 160px;
    }
    /* Episode rows table */
    .flex-table.episodes {
      grid-template-columns: 60px 220px 140px 1fr 110px 130px 130px 110px 110px 80px 160px;
    }
    /* Movies table */
    .flex-table.movies {
      grid-template-columns: 120px 220px 1fr 140px 100px 110px 130px 130px 110px 110px 80px 160px;
    }

    /* Icon sets */
    .icons { display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    .icon-btn {
      border: 1px solid #555; background:#222; color: var(--fg);
      border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.95em;
    }
    .icon-btn:hover { background:#2a2a2a }
    .icon-link { text-decoration:none; border:1px solid #555; background:#222; color: var(--fg); border-radius:4px; padding:4px 8px; }
    .icon-link:hover { background:#2a2a2a }

    /* Status badges */
    .status-watched { color: var(--green); font-weight: bold; }
    .status-watching { color: var(--blue); font-weight: bold; }
    .status-none { color: var(--red); font-weight: bold; }

    /* Hidden utility */
    .hidden{ display:none !important }
    .error { color: var(--red); padding: 8px 12px; background:#1a1a1a; border:1px solid #444; margin-top:8px }

    /* Links inside cells */
    .cell a { color: var(--accent); word-break: break-all }
  </style>
</head>
<body>

<h1>The Boys Shows</h1>

<!-- Global controls -->
<div class="controls">
  <label><input type="checkbox" id="hideComplete"> <span>Hide complete (‚úÖ watched)</span></label>
  <label><input type="checkbox" id="watchingOnly"> <span>Show ‚Äúwatching‚Äù only (hide ‚úÖ and ‚ùå)</span></label>
  <button class="btn" id="collapseAll">Collapse all</button>
  <button class="btn" id="expandAll">Expand all</button>
  <button class="btn" id="clearStatuses">Clear local statuses</button>
</div>

<details class="block-show" id="showsSection">
  <summary>+/- Shows</summary>
  <div id="shows"></div>
</details>

<details class="block-item" id="moviesSection">
  <summary>+/- Movies</summary>
  <div id="movies"></div>
</details>

<div id="errors"></div>

<script>
/* Config */
const DATA_URL = 'https://raw.githubusercontent.com/AJPnKW/IPTV_Data_Harmonization_System/main/docs/show_and_movie_data.tile.txt';

/* Base link builders */
const linkBuilders = {
  tmdbShow: id => `https://www.themoviedb.org/tv/${id}`,
  tmdbMovie: id => `https://www.themoviedb.org/movie/${id}`,
  vidjoyTv: (id,s,e) => `https://vidjoy.pro/embed/tv/${id}/${s}/${e}`,
  vidjoyMovie: id => `https://vidjoy.pro/embed/movie/${id}`,
  vidsrcTv: (id,s,e) => `https://vidsrc.net/embed/tv/${id}/${s}/${e}`,
  vidsrcMovie: id => `https://vidsrc.net/embed/movie/${id}`,
  mappleTv: (id,s,e) => `https://mapple.tv/watch/tv/${id}/${s}/${e}`,
  mappleMovie: id => `https://mapple.tv/watch/movie/${id}`,
  nunflixTv: (id,s,e) => `https://nunflix.cc/watch/tv/${id}/${s}/${e}`,
  nunflixMovie: id => `https://nunflix.cc/watch/movie/${id}`
};

/* Icons by type */
const ICONS = {
  status: {
    watching: '‚è≥',
    watched: '‚úÖ',
    unmark: '‚ùå'
  },
  link: {
    TMDB: 'üåê',
    VidJoy: 'üì∫',
    VidSrc: 'üì∫',
    Mapple: 'üåê',
    NunFlix: 'üé¨'
  },
  app: {
    Netflix: 'üÖΩ',
    Prime: 'üÖø',
    Disney: 'üÖ≥'
  },
  misc: {
    TBD: '‚ùì'
  }
};

/* Utility: escape HTML */
function esc(s){ return String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) }

/* LocalStorage for statuses: key schema */
function keyEpisode(tmdbId, season, ep){ return `status:ep:${tmdbId}:${season}:${ep}` }
function keyMovie(tmdbId){ return `status:mv:${tmdbId}` }

/* Status helpers */
function statusClass(s){
  const v = (s||'').toLowerCase();
  if (v.includes('watched')) return 'status-watched';
  if (v.includes('watching')) return 'status-watching';
  return 'status-none';
}
function normalizeStatus(s){
  const v = (s||'').toLowerCase();
  if (v.includes('watched')) return 'watched';
  if (v.includes('watching')) return 'watching';
  return 'none';
}

/* Global filters */
const filters = {
  hideComplete: false,
  watchingOnly: false
};

/* Parse data with validation and resilience */
async function loadData(){
  let text;
  try{
    const res = await fetch(DATA_URL);
    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
    text = await res.text();
  }catch(err){
    reportError(`Failed to load data file: ${err.message}`);
    return { shows: {}, movies: [] };
  }

  const lines = text.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));

  const shows = {};
  const movies = [];
  let currentShow = null;
  let currentSeason = null;

  for (let i=0;i<lines.length;i++){
    const line = lines[i];
    const parts = line.split('|').map(p => p.trim());
    const type = parts[0];

    try{
      switch(type){
        case 'show': {
          // show|tmdb_id|name|overview|date|status|source|schedule|tmdb_url_link
          if (parts.length < 9) throw new Error('show: insufficient fields');
          const [, id, name, overview, date, status, source, schedule, url] = parts;
          currentShow = { id, name, overview, date, status, source, schedule, url, seasons: [] };
          shows[id] = currentShow;
          currentSeason = null;
          break;
        }
        case 'season': {
          // season|tmdb_id|seasonNum|year|overview|watchStatus
          if (parts.length < 6) throw new Error('season: insufficient fields');
          const [, showId, seasonNum, year, overview, watchStatus] = parts;
          if (!shows[showId]) throw new Error(`season references unknown showId: ${showId}`);
          currentSeason = { seasonNum, year, overview, watchStatus, episodes: [] };
          shows[showId].seasons.push(currentSeason);
          break;
        }
        case 'episode': {
          // episode|tmdb_id|epNum|title|date|desc|runtime|source|vidSrc|mapple|nunFlix|tbd|watchStatus
          if (parts.length < 13) throw new Error('episode: insufficient fields');
          const [, showId, epNum, title, date, desc, runtime, source, vidSrc, mapple, nunFlix, tbd, watchStatus] = parts;
          if (!currentSeason) throw new Error('episode before season');
          if (!shows[showId]) throw new Error(`episode references unknown showId: ${showId}`);
          currentSeason.episodes.push({ showId, epNum, title, date, desc, runtime, source, vidSrc, mapple, nunFlix, tbd, watchStatus });
          break;
        }
        case 'movie': {
          // movie|tmdb_id|name|overview|releaseDate|rating|runtime|source|vidSrc|mapple|nunFlix|tbd|watchStatus
          if (parts.length < 13) throw new Error('movie: insufficient fields');
          const [, id, name, overview, releaseDate, rating, runtime, source, vidSrc, mapple, nunFlix, tbd, watchStatus] = parts;
          movies.push({ id, name, overview, releaseDate, rating, runtime, source, vidSrc, mapple, nunFlix, tbd, watchStatus });
          break;
        }
        default:
          throw new Error(`Unknown type: ${type}`);
      }
    }catch(err){
      console.warn(`Parse warning [line ${i+1}]: ${err.message} | ${line}`);
    }
  }

  return { shows, movies };
}

/* Error reporting */
function reportError(msg){
  const errors = document.getElementById('errors');
  const div = document.createElement('div');
  div.className = 'error';
  div.textContent = msg;
  errors.appendChild(div);
}

/* Build icon link group for episodes/movies */
function buildLinksForEpisode(ep, seasonNum){
  const id = ep.showId;
  const s = seasonNum;
  const e = ep.epNum;
  const nodes = [];

  // TMDB
  nodes.push(aLink(ICONS.link.TMDB+' TMDB', linkBuilders.tmdbShow(id)));

  // VidJoy / VidSrc / Mapple / NunFlix
  nodes.push(aLink(ICONS.link.VidJoy+' VidJoy', linkBuilders.vidjoyTv(id,s,e)));
  nodes.push(aLink(ICONS.link.VidSrc+' VidSrc', linkBuilders.vidsrcTv(id,s,e)));
  nodes.push(aLink(ICONS.link.Mapple+' Mapple', linkBuilders.mappleTv(id,s,e)));
  nodes.push(aLink(ICONS.link.NunFlix+' NunFlix', linkBuilders.nunflixTv(id,s,e)));

  // App generic search/open (web)
  nodes.push(aLink('üîé Search', `https://www.google.com/search?q=${encodeURIComponent(ep.title)}+${encodeURIComponent(ep.showId)}+Season+${encodeURIComponent(s)}+Episode+${encodeURIComponent(e)}`));

  return nodes;
}

function buildLinksForMovie(mv){
  const nodes = [];
  nodes.push(aLink(ICONS.link.TMDB+' TMDB', linkBuilders.tmdbMovie(mv.id)));
  nodes.push(aLink(ICONS.link.VidJoy+' VidJoy', linkBuilders.vidjoyMovie(mv.id)));
  nodes.push(aLink(ICONS.link.VidSrc+' VidSrc', linkBuilders.vidsrcMovie(mv.id)));
  nodes.push(aLink(ICONS.link.Mapple+' Mapple', linkBuilders.mappleMovie(mv.id)));
  nodes.push(aLink(ICONS.link.NunFlix+' NunFlix', linkBuilders.nunflixMovie(mv.id)));
  nodes.push(aLink('üîé Search', `https://www.google.com/search?q=${encodeURIComponent(mv.name)}+${encodeURIComponent(mv.id)}`));
  return nodes;
}

/* Create anchor element */
function aLink(text, href){
  const a = document.createElement('a');
  a.className = 'icon-link';
  a.href = href;
  a.target = '_blank';
  a.rel = 'noopener noreferrer';
  a.textContent = text;
  return a;
}

/* Status toggle buttons with localStorage persistence */
function statusButtons({ key, initial }){
  const wrap = document.createElement('div');
  wrap.className = 'icons';

  const current = normalizeStatus(localStorage.getItem(key) || initial);

  const lbl = document.createElement('span');
  lbl.className = statusClass(current);
  lbl.textContent = current === 'watched' ? `${ICONS.status.watched} watched`
                   : current === 'watching' ? `${ICONS.status.watching} watching`
                   : `${ICONS.status.unmark} none`;
  wrap.appendChild(lbl);

  const btnWatch = document.createElement('button');
  btnWatch.className = 'icon-btn';
  btnWatch.textContent = ICONS.status.watching+' watching';
  btnWatch.onclick = () => { localStorage.setItem(key,'watching'); updateStatus(lbl,'watching') };
  wrap.appendChild(btnWatch);

  const btnDone = document.createElement('button');
  btnDone.className = 'icon-btn';
  btnDone.textContent = ICONS.status.watched+' watched';
  btnDone.onclick = () => { localStorage.setItem(key,'watched'); updateStatus(lbl,'watched') };
  wrap.appendChild(btnDone);

  const btnClear = document.createElement('button');
  btnClear.className = 'icon-btn';
  btnClear.textContent = ICONS.status.unmark+' unmark';
  btnClear.onclick = () => { localStorage.removeItem(key); updateStatus(lbl,'none') };
  wrap.appendChild(btnClear);

  return wrap;
}
function updateStatus(label, status){
  label.className = statusClass(status);
  label.textContent = status === 'watched' ? `${ICONS.status.watched} watched`
                    : status === 'watching' ? `${ICONS.status.watching} watching`
                    : `${ICONS.status.unmark} none`;
}

/* Global filter logic */
function shouldHideByFilters(status){
  const s = normalizeStatus(status);
  if (filters.watchingOnly){
    // keep only 'watching'
    return s !== 'watching';
  }
  if (filters.hideComplete){
    // hide 'watched'
    return s === 'watched';
  }
  return false;
}

/* Render functions */
function renderShows(shows){
  const container = document.getElementById('shows');
  container.innerHTML = '';

  Object.values(shows).forEach(show => {
    // SHOW BLOCK
    const showDetails = document.createElement('details');
    showDetails.open = false;
    showDetails.className = 'block-show';
    const showSummary = document.createElement('summary');
    showSummary.innerHTML = `<span class="title-show">${esc(show.name)}</span>`;
    showDetails.appendChild(showSummary);

    // Show header as flex grid
    const showHeader = document.createElement('div');
    showHeader.className = 'flex-table show flex-header';
    const headers = ['TMDB ID','Overview','Date','Status','Source','Schedule'];
    const values  = [show.id, show.overview, show.date, show.status, show.source, show.schedule];
    headers.forEach((h, idx) => {
      const c = document.createElement('div'); c.className='cell'; c.textContent=h; showHeader.appendChild(c);
      const v = document.createElement('div'); v.className='cell'; v.innerHTML=esc(values[idx] ?? '');
      showHeader.appendChild(v);
    });
    showDetails.appendChild(showHeader);

    // Show link row
    const showLinks = document.createElement('div');
    showLinks.className = 'icons';
    // Primary TMDB (from file if present, else builder)
    const tmdbUrl = show.url ? show.url : linkBuilders.tmdbShow(show.id);
    showLinks.appendChild(aLink(ICONS.link.TMDB+' TMDB', tmdbUrl));
    showDetails.appendChild(showLinks);

    // SEASONS
    show.seasons.forEach(season => {
      const seasonDetails = document.createElement('details');
      seasonDetails.open = false;
      seasonDetails.className = 'block-season';
      const seasonSummary = document.createElement('summary');
      seasonSummary.innerHTML = `<span class="title-season">Season ${esc(season.seasonNum)} (${esc(season.year)}) ‚Ä¢ ${season.episodes.length} episodes</span>`;
      seasonDetails.appendChild(seasonSummary);

      // Season header
      const sh = document.createElement('div');
      sh.className = 'flex-table season flex-header';
      const shHeaders = ['Season #','Year','Overview','Watch status'];
      const shValues = [season.seasonNum, season.year, season.overview, season.watchStatus];
      shHeaders.forEach((h, idx) => {
        const c = document.createElement('div'); c.className='cell'; c.textContent=h; sh.appendChild(c);
        const v = document.createElement('div'); v.className='cell'; 
        if (idx===3){
          const sKey = `status:season:${show.id}:${season.seasonNum}`;
          const wrap = statusButtons({ key: sKey, initial: season.watchStatus });
          v.appendChild(wrap);
        }else{
          v.innerHTML = esc(shValues[idx] ?? '');
        }
        sh.appendChild(v);
      });
      seasonDetails.appendChild(sh);

      // EPISODES TABLE (flex layout)
      if (season.episodes.length){
        const epTable = document.createElement('div');
        epTable.className = 'flex-table episodes';
        // Header
        const headers = ['#','Title','Date','Description','Runtime','Source','VidJoy','VidSrc','Mapple','NunFlix','Status'];
        headers.forEach(h => { const c = document.createElement('div'); c.className='cell'; c.textContent=h; epTable.appendChild(c); });

        // Rows
        season.episodes.forEach(ep => {
          const statusKey = keyEpisode(ep.showId, season.seasonNum, ep.epNum);
          const cur = normalizeStatus(localStorage.getItem(statusKey) || ep.watchStatus);

          // Filter visibility
          if (shouldHideByFilters(cur)) return;

          const vals = [
            esc(ep.epNum),
            esc(ep.title),
            esc(ep.date),
            esc(ep.desc),
            esc(ep.runtime),
            esc(ep.source)
          ];
          vals.forEach(v => {
            const c = document.createElement('div'); c.className='cell'; c.innerHTML=v; epTable.appendChild(c);
          });

          // Link buttons
          const linkCell = document.createElement('div'); linkCell.className='cell';
          const links = buildLinksForEpisode(ep, season.seasonNum);
          const iconWrap = document.createElement('div'); iconWrap.className='icons';
          links.forEach(node => iconWrap.appendChild(node));
          linkCell.appendChild(iconWrap);
          epTable.appendChild(linkCell);

          // Status controls
          const stCell = document.createElement('div'); stCell.className='cell';
          const stWrap = statusButtons({ key: statusKey, initial: ep.watchStatus });
          stCell.appendChild(stWrap);
          epTable.appendChild(stCell);
        });

        seasonDetails.appendChild(epTable);
      }

      showDetails.appendChild(seasonDetails);
    });

    container.appendChild(showDetails);
  });
}

function renderMovies(movies){
  const container = document.getElementById('movies');
  container.innerHTML = '';

  // Movies table
  const mvTable = document.createElement('div');
  mvTable.className = 'flex-table movies';

  // Header
  ['TMDB ID','Name','Overview','Release','Rating','Runtime','Source','VidJoy','VidSrc','Mapple','NunFlix','Status'].forEach(h => {
    const c = document.createElement('div'); c.className='cell'; c.textContent=h; mvTable.appendChild(c);
  });

  movies.forEach(mv => {
    const statusKey = keyMovie(mv.id);
    const cur = normalizeStatus(localStorage.getItem(statusKey) || mv.watchStatus);
    if (shouldHideByFilters(cur)) return;

    const vals = [
      esc(mv.id),
      esc(mv.name),
      esc(mv.overview),
      esc(mv.releaseDate),
      esc(mv.rating),
      esc(mv.runtime),
      esc(mv.source)
    ];
    vals.forEach(v => { const c = document.createElement('div'); c.className='cell'; c.innerHTML=v; mvTable.appendChild(c); });

    // Link buttons
    const linkCell = document.createElement('div'); linkCell.className='cell';
    const links = buildLinksForMovie(mv);
    const iconWrap = document.createElement('div'); iconWrap.className='icons';
    links.forEach(node => iconWrap.appendChild(node));
    linkCell.appendChild(iconWrap);
    mvTable.appendChild(linkCell);

    // Status controls
    const stCell = document.createElement('div'); stCell.className='cell';
    const stWrap = statusButtons({ key: statusKey, initial: mv.watchStatus });
    stCell.appendChild(stWrap);
    mvTable.appendChild(stCell);
  });

  container.appendChild(mvTable);
}

/* Collapse/expand helpers */
function setAllDetails(open){
  document.querySelectorAll('details').forEach(d => d.open = !!open);
}

/* Wire up global controls */
function initControls(){
  const hideComplete = document.getElementById('hideComplete');
  const watchingOnly = document.getElementById('watchingOnly');
  hideComplete.onchange = () => { filters.hideComplete = hideComplete.checked; refresh(); };
  watchingOnly.onchange = () => { filters.watchingOnly = watchingOnly.checked; refresh(); };

  document.getElementById('collapseAll').onclick = () => setAllDetails(false);
  document.getElementById('expandAll').onclick = () => setAllDetails(true);
  document.getElementById('clearStatuses').onclick = () => {
    Object.keys(localStorage).forEach(k => { if (k.startsWith('status:')) localStorage.removeItem(k) });
    refresh();
  };
}

/* Refresh */
let cache = { shows:{}, movies:[] };
async function refresh(){
  // Re-render from cache to apply filters quickly
  document.getElementById('shows').innerHTML = '';
  document.getElementById('movies').innerHTML = '';
  renderShows(cache.shows);
  renderMovies(cache.movies);
}

/* Init */
(async function(){
  initControls();
  try{
    cache = await loadData();
    renderShows(cache.shows);
    renderMovies(cache.movies);
    // Start collapsed by default
    setAllDetails(false);
    console.log('Data loaded:', { shows:Object.keys(cache.shows).length, movies:cache.movies.length });
  }catch(err){
    reportError(`Runtime error: ${err.message}`);
  }
})();
</script>

</body>
</html>
